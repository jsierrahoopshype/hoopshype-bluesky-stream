<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bluesky Watchlist</title>
  <style>
    :root{
      --bg:#fff; --text:#111; --muted:#5a6573;
      --panel:#fff; --border:#d9e0ea; --accent:#0b77ff;
      --chip:#f4f7fb;
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    h1{font-weight:700;font-size:20px;margin:0 0 12px}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="number"],input[type="text"],select{
      background:#fff;border:1px solid var(--border);color:var(--text);
      padding:8px 10px;border-radius:8px
    }
    input[type="checkbox"]{transform:translateY(1px)}
    button{
      background:var(--accent);color:#fff;border:0;border-radius:8px;
      padding:9px 14px;font-weight:700;cursor:pointer
    }
    button.secondary{background:#eef3fb;color:#0b2b60;border:1px solid var(--border)}
    .chips{max-height:220px;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:8px;background:#fff}
    .chip{display:inline-flex;align-items:center;gap:8px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:999px;padding:6px 10px;margin:6px 6px 0 0;white-space:nowrap}
    .muted{color:var(--muted)}
    .results{display:flex;flex-direction:column;gap:12px;margin-top:10px}
    .item{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff}
    .item .meta{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;gap:8px;flex-wrap:wrap}
    .item img{max-width:100%;border-radius:8px;margin-top:8px;display:block}
    .right-sticky{position:sticky;top:12px;height:calc(100dvh - 48px)}
    .right-sticky .card{height:100%;display:flex;flex-direction:column}
    .right-sticky .card textarea{flex:1;min-height:200px;background:#fff;border:1px solid var(--border);border-radius:12px;color:var(--text);padding:10px;resize:vertical}
    .pill{display:inline-flex;background:#eef3fb;border:1px solid var(--border);border-radius:999px;padding:4px 8px;font-size:12px;margin-right:6px}
    .spinner{display:none}
    .spinner.on{display:inline-block;inline-size:14px;block-size:14px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{color:#c21d12;font-weight:600}
    a { color:#0b58d1; text-decoration:none }
    a:hover{ text-decoration:underline }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Bluesky Watchlist</h1>
    <div class="grid">
      <div class="card">
        <div class="row">
          <input id="q" type="text" placeholder="(optional filter in post text)" style="flex:1 1 320px">
          <label>Lookback (hours) <input id="hours" type="number" min="1" value="6" style="width:80px"></label>
          <label>Min reposts <input id="minReposts" type="number" min="0" value="0" style="width:70px"></label>
          <label>Min likes <input id="minLikes" type="number" min="0" value="0" style="width:70px"></label>
          <label>Limit (total) <input id="limit" type="number" min="1" value="60" style="width:80px"></label>
        </div>
        <div class="row" style="margin-top:8px">
          <select id="sort">
            <option value="desc">Recent (desc)</option>
            <option value="asc">Oldest (asc)</option>
            <option value="likes">Most likes</option>
            <option value="reposts">Most reposts</option>
          </select>
          <label><input id="incReplies" type="checkbox"> Include replies</label>
          <label><input id="incQuotes" type="checkbox" checked> Include quotes</label>
          <label><input id="excReposts" type="checkbox" checked> Exclude reposts</label>
          <label><input id="nocache" type="checkbox" checked> nocache</label>
          <button id="searchBtn">Search <span id="spin" class="spinner"></span></button>
          <button id="allBtn" class="secondary">All</button>
          <button id="noneBtn" class="secondary">None</button>
          <span id="err" class="error" role="alert"></span>
        </div>

        <div class="muted" style="margin-top:10px">Accounts (from <code>reporters.csv</code>)</div>
        <div id="accountsBox" class="chips"></div>

        <div id="results" class="results"></div>
      </div>

      <div class="right-sticky">
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div class="muted">Selected <span id="selCount">0</span></div>
            <label class="muted"><input id="priorityFirst" type="checkbox" checked> Priority first</label>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="copyTxt">Copy plain text</button>
            <button id="copyCsv" class="secondary">Copy CSV</button>
            <button id="copyHtml" class="secondary">Copy publisher-safe HTML</button>
          </div>
          <div class="muted" style="margin-top:10px">Preview of copied output…</div>
          <textarea id="preview" spellcheck="false"></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- helpers
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // ---------- persistence via Netlify Blobs + local fallback
    const BLOB_KEY = 'watchlist-accounts';
    async function loadBlobFull(){
      try{
        const r=await fetch('/api/watchlist-accounts');
        if(!r.ok) return null;
        const j=await r.json();
        return j && typeof j==='object' ? j : null;
      }catch{return null}
    }
    async function saveBlob(enabled){
      try{
        await fetch('/api/watchlist-accounts',{
          method:'POST',headers:{'content-type':'application/json'},
          body:JSON.stringify({enabled})
        });
      }catch{}
    }
    function loadLocal(){
      try{const s=localStorage.getItem(BLOB_KEY);return s?JSON.parse(s):null}catch{return null}
    }
    function saveLocal(enabled){try{localStorage.setItem(BLOB_KEY,JSON.stringify(enabled))}catch{}}

    // ---------- reporters.csv
    async function fetchReporters(){
      const res = await fetch('/reporters.csv?_=' + Date.now());
      const txt = await res.text();
      const lines = txt.trim().split(/\r?\n/).filter(Boolean);
      return lines.map(line=>{
        const [h,p] = line.split(',').map(s=>s.trim());
        const handle = h.startsWith('@')?h:'@'+h;
        const priority = (p||'').toLowerCase()==='true';
        return {handle, priority};
      });
    }

    function utm(url){
      try{
        const u = new URL(url);
        if(!u.searchParams.has('utm_source')) u.searchParams.set('utm_source','hoopshype');
        return u.toString();
      }catch{return url}
    }

    // make plain URLs clickable in text
    function linkify(str){
      if(!str) return '';
      return str.replace(/(https?:\/\/[^\s<>"')]+)(?<![.,!?:;])/g, m => `<a href="${m}" target="_blank" rel="noopener">${m}</a>`);
    }

    function extractVideoUrlFrom(anyTextOrHtml){
      const s = String(anyTextOrHtml||'');
      const urls = s.match(/https?:\/\/[^\s"')]+/g) || [];
      return urls.find(u=>/(youtube\.com|youtu\.be|vimeo\.com|\.mp4($|\?)|\.webm($|\?)|\.mov($|\?))/i.test(u)) || '';
    }

    // stronger repost detector
    function isRepost(it){
      if (it.isRepost === true) return true;
      const h = (it.html||'').replace(/<[^>]+>/g,' ').trim();
      const t = (it.text||'').trim();
      if (/^\[?\s*repost\b/i.test(h)) return true;
      if (/^\[?\s*repost\b/i.test(t)) return true;
      return false;
    }

    // render accounts list
    async function buildAccountsUI(){
      const reporters = await fetchReporters();
      const allHandles = reporters.map(r=>r.handle);
      const box = $('#accountsBox'); box.innerHTML='';

      const server = await loadBlobFull();
      const local = loadLocal();

      // If server has never been saved (updatedAt null) and it's empty, ignore it.
      let enabled;
      if (server && Array.isArray(server.enabled) && server.updatedAt) {
        enabled = server.enabled.slice();
      } else if (local!==null) {
        enabled = local.slice();
      } else {
        enabled = allHandles.slice(); // FIRST LOAD: select all
      }

      reporters.forEach((r,i)=>{
        const id='acc_'+i;
        const checked = enabled.includes(r.handle);
        const el = document.createElement('label');
        el.className='chip';
        el.innerHTML = `<input type="checkbox" id="${id}" data-handle="${r.handle}" ${checked?'checked':''}/>
                        <span>${r.handle}</span>${r.priority?'<span class="pill">priority</span>':''}`;
        box.appendChild(el);
      });

      box.addEventListener('change', ()=>{
        const list = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        saveLocal(list); saveBlob(list);
      });

      return reporters;
    }

    // results rendering
    function renderItems(items){
      const container = $('#results'); container.innerHTML='';
      const frag = document.createDocumentFragment();

      items.forEach((it,i)=>{
        // prefer html if present, otherwise text with linkify
        const bodyHtml = it.html ? linkify(it.html) : linkify(
          (it.text||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')
        );

        // discover a probable video URL
        const vUrl = it.videoUrl || it.mediaUrl || extractVideoUrlFrom(it.html||it.text);

        const el = document.createElement('div');
        el.className='item';
        el.innerHTML = `
          <label style="display:flex;gap:10px;align-items:start;">
            <input type="checkbox" data-idx="${i}" />
            <div style="flex:1">
              <div class="meta">
                <span>${it.authorDisplay || it.authorHandle || ''}</span>
                ${it.authorHandle?`<span class="muted">${it.authorHandle}</span>`:''}
                ${it.tsLocal?`<span class="muted">${it.tsLocal}</span>`:''}
                ${typeof it.likeCount==='number'?`<span class="muted">❤ ${it.likeCount}</span>`:''}
                ${typeof it.repostCount==='number'?`<span class="muted">↻ ${it.repostCount}</span>`:''}
              </div>
              <div>${bodyHtml}</div>
              ${vUrl ? `<div class="muted" style="margin-top:6px;"><a href="${vUrl}" target="_blank" rel="noopener">Open video</a></div>` : ''}
              ${it.url?`<div class="muted" style="margin-top:6px"><a href="${utm(it.url)}" target="_blank" rel="noopener">Open on Bluesky</a></div>`:''}
            </div>
          </label>
        `;
        frag.appendChild(el);
      });

      container.appendChild(frag);
      updateSelectedCounts();
      container.addEventListener('change',(e)=>{ if(e.target.matches('input[type="checkbox"]')) updateSelectedCounts(); });
    }

    function updateSelectedCounts(){ $('#selCount').textContent = $$('#results input[type="checkbox"]:checked').length; }

    // one-line plain text
    function oneline(s){ return (s||'').replace(/\s*\n+\s*/g,' ').replace(/\s\s+/g,' ').trim(); }

    function collectSelected(items){
      const idx = new Set($$('#results input[type="checkbox"]:checked').map(i=>+i.dataset.idx));
      return items.filter((_,i)=>idx.has(i));
    }

    function copyPlain(selected){
      const lines = selected.map(s=>{
        const author = s.authorDisplay || s.authorHandle || '';
        const text = oneline(s.text || (s.html? s.html.replace(/<[^>]+>/g,' ') : ''));
        const link = utm(s.url || '');
        return `${author}: ${text} ${link}`.trim();
      });
      const out = lines.join('\n');
      navigator.clipboard.writeText(out);
      $('#preview').value = out;
    }
    function toCSV(rows){
      const esc=v=>`"${String(v??'').replace(/"/g,'""')}"`;
      const head=['authorDisplay','authorHandle','tsLocal','likeCount','repostCount','url','text'];
      const lines=[head.map(esc).join(',')];
      rows.forEach(r=>lines.push([r.authorDisplay,r.authorHandle,r.tsLocal,r.likeCount,r.repostCount,utm(r.url||''),oneline(r.text|| (r.html? r.html.replace(/<[^>]+>/g,' ') : ''))].map(esc).join(',')));
      return lines.join('\n');
    }
    function copyCSV(selected){
      const out=toCSV(selected); navigator.clipboard.writeText(out); $('#preview').value=out;
    }
    function copyHTML(selected){
      const html = selected.map(s=>{
        const line1 = `<strong>${s.authorDisplay || s.authorHandle || ''}</strong> <span style="color:#667">${s.tsLocal || ''}</span>`;
        const text = (s.html ? s.html : (s.text||'').replace(/\n/g,'<br>'));
        const link = s.url ? ` <a href="${utm(s.url)}" target="_blank" rel="noopener">${utm(s.url)}</a>` : '';
        return `<p>${line1}<br>${text}${link}</p>`;
      }).join('\n');
      navigator.clipboard.writeText(html); $('#preview').value=html;
    }

    // ----------- STREAM: fetch EACH author (small concurrency), then merge
    async function fetchStreamForAuthor(author, opts){
      const { q,hours,minReposts,minLikes,includeReplies,includeQuotes,excludeReposts,perAuthorLimit,sort,nocache,priorityFirst } = opts;
      const qs = new URLSearchParams({
        q:q||'', hours:hours||6, minReposts:minReposts||0, minLikes:minLikes||0,
        includeReplies: includeReplies?1:0, includeQuotes: includeQuotes?1:0,
        authors: author, limit: perAuthorLimit, sort: sort||'desc',
        nocache: nocache?1:0, priorityFirst: priorityFirst?1:0
      });
      const r = await fetch('/api/stream?'+qs.toString());
      if(!r.ok) return [];
      const j = await r.json();
      return Array.isArray(j.items) ? j.items : [];
    }

    async function runSearch(reporters){
      $('#err').textContent=''; $('#spin').classList.add('on');
      try{
        const q=$('#q').value.trim();
        const hours=+$('#hours').value||6;
        const minReposts=+$('#minReposts').value||0;
        const minLikes=+$('#minLikes').value||0;
        const limit=+$('#limit').value||60;
        const sort=$('#sort').value;
        const includeReplies=$('#incReplies').checked;
        const includeQuotes=$('#incQuotes').checked;
        const excludeReposts=$('#excReposts').checked;
        const nocache=$('#nocache').checked;
        const priorityFirst=$('#priorityFirst').checked;

        const authors = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        if(authors.length===0){ renderItems([]); window.__items=[]; return; }

        // over-fetch per author to avoid starvation
        const perAuthorLimit = Math.max(15, Math.ceil((limit*3)/authors.length));

        // small concurrency pool (8)
        const out = [];
        const pool = [];
        const MAX = 8;

        for(const a of authors){
          const job = (async ()=>{
            const items = await fetchStreamForAuthor(a,{
              q,hours,minReposts,minLikes,includeReplies,includeQuotes,excludeReposts,
              perAuthorLimit,sort,nocache,priorityFirst
            });
            out.push(...items);
          })();
          pool.push(job);
          if(pool.length>=MAX){ await Promise.race(pool); // wait for one to finish
            // clean finished
            for(let i=pool.length-1;i>=0;i--) if(pool[i].status==='fulfilled'||pool[i].status==='rejected') pool.splice(i,1);
          }
        }
        await Promise.allSettled(pool);

        // filter FIRST
        let filtered = out;
        if (excludeReposts) filtered = filtered.filter(it=>!isRepost(it));

        // dedupe by URL (or hash)
        const seen = new Set(); const merged=[];
        for(const it of filtered){
          const k = it.url || `${it.ts}|${it.authorHandle}|${(it.text||'').slice(0,40)}`;
          if(!seen.has(k)){ seen.add(k); merged.push(it); }
        }

        // sort
        if (sort==='likes') merged.sort((a,b)=>(b.likeCount||0)-(a.likeCount||0));
        else if (sort==='reposts') merged.sort((a,b)=>(b.repostCount||0)-(a.repostCount||0));
        else if (sort==='asc') merged.sort((a,b)=> new Date(a.ts||a.tsLocal||0)-new Date(b.ts||b.tsLocal||0));
        else merged.sort((a,b)=> new Date(b.ts||b.tsLocal||0)-new Date(a.ts||a.tsLocal||0));

        const final = merged.slice(0,limit);
        window.__items = final;
        renderItems(final);
      }catch(e){ $('#err').textContent=e.message||'Error'; renderItems([]); window.__items=[]; }
      finally{ $('#spin').classList.remove('on'); }
    }

    let reportersCache = null;

    async function init(){
      reportersCache = await buildAccountsUI();

      $('#allBtn').addEventListener('click',()=>{
        $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=true);
        const list=$$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        saveLocal(list); saveBlob(list);
      });
      $('#noneBtn').addEventListener('click',()=>{
        $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=false);
        saveLocal([]); saveBlob([]);
      });

      $('#searchBtn').addEventListener('click',()=>runSearch(reportersCache));
      $('#copyTxt').addEventListener('click',()=>copyPlain(collectSelected(window.__items||[])));
      $('#copyCsv').addEventListener('click',()=>copyCSV(collectSelected(window.__items||[])));
      $('#copyHtml').addEventListener('click',()=>copyHTML(collectSelected(window.__items||[])));

      // FIRST LOAD: if server blob is “never saved” (updatedAt null), select all and run
      await sleep(60); // allow DOM to settle
      const server = await loadBlobFull();
      const local = loadLocal();
      if ((server===null || !server.updatedAt) && local===null) {
        $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=true);
      }
      runSearch(reportersCache);
    }

    function updateSelectedCounts(){ $('#selCount').textContent = $$('#results input[type="checkbox"]:checked').length; }

    init();
  </script>
</body>
</html>

