<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bluesky Watchlist</title>
  <style>
    :root{
      --bg:#fff; --text:#111; --muted:#5a6573;
      --panel:#fff; --border:#d9e0ea; --accent:#0b77ff;
      --chip:#f4f7fb;
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    h1{font-weight:700;font-size:20px;margin:0 0 12px}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row > *{min-height:36px}
    input[type="number"],input[type="text"],select{
      background:#fff;border:1px solid var(--border);color:var(--text);
      padding:8px 10px;border-radius:8px
    }
    input[type="checkbox"]{transform:translateY(1px)}
    button{
      background:var(--accent);color:#fff;border:0;border-radius:8px;
      padding:9px 14px;font-weight:700;cursor:pointer
    }
    button.secondary{background:#eef3fb;color:#0b2b60;border:1px solid var(--border)}
    .chips{max-height:220px;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:8px;background:#fff}
    .chip{display:inline-flex;align-items:center;gap:8px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:999px;padding:6px 10px;margin:6px 6px 0 0;white-space:nowrap}
    .muted{color:var(--muted)}
    .results{display:flex;flex-direction:column;gap:12px;margin-top:10px}
    .item{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff}
    .item .meta{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;gap:8px;flex-wrap:wrap}
    .item img{max-width:100%;border-radius:8px;margin-top:8px;display:block}
    .right-sticky{position:sticky;top:12px;height:calc(100dvh - 48px)}
    .right-sticky .card{height:100%;display:flex;flex-direction:column}
    .right-sticky .card textarea{flex:1;min-height:200px;background:#fff;border:1px solid var(--border);border-radius:12px;color:var(--text);padding:10px;resize:vertical}
    .pill{display:inline-flex;background:#eef3fb;border:1px solid var(--border);border-radius:999px;padding:4px 8px;font-size:12px;margin-right:6px}
    .spinner{display:none}
    .spinner.on{display:inline-block;inline-size:14px;block-size:14px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{color:#c21d12;font-weight:600}
    a { color:#0b58d1; text-decoration:none }
    a:hover{ text-decoration:underline }
    .links{margin-top:6px;font-size:12px;color:var(--muted)}
    .links a{margin-right:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Bluesky Watchlist</h1>
    <div class="grid">
      <div class="card">
        <div class="row">
          <input id="q" type="text" placeholder="(optional filter in post text)" style="flex:1 1 320px">
          <label>Lookback (hours) <input id="hours" type="number" min="1" value="6" style="width:80px"></label>
          <label>Min reposts <input id="minReposts" type="number" min="0" value="0" style="width:70px"></label>
          <label>Min likes <input id="minLikes" type="number" min="0" value="0" style="width:70px"></label>
          <label>Limit (total) <input id="limit" type="number" min="1" value="60" style="width:80px"></label>
        </div>
        <div class="row" style="margin-top:8px">
          <select id="sort">
            <option value="desc">Recent (desc)</option>
            <option value="asc">Oldest (asc)</option>
            <option value="likes">Most likes</option>
            <option value="reposts">Most reposts</option>
          </select>
          <label><input id="incReplies" type="checkbox"> Include replies</label>
          <label><input id="incQuotes" type="checkbox" checked> Include quotes</label>
          <label><input id="excReposts" type="checkbox" checked> Exclude reposts</label>
          <label><input id="nocache" type="checkbox" checked> nocache</label>
          <button id="searchBtn">Search <span id="spin" class="spinner"></span></button>
          <button id="allBtn" class="secondary">All</button>
          <button id="noneBtn" class="secondary">None</button>
          <span id="err" class="error" role="alert"></span>
        </div>

        <div class="muted" style="margin-top:10px">Accounts (from <code>reporters.csv</code>)</div>
        <div id="accountsBox" class="chips"></div>

        <div id="results" class="results"></div>
      </div>

      <div class="right-sticky">
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div class="muted">Selected <span id="selCount">0</span></div>
            <label class="muted"><input id="priorityFirst" type="checkbox" checked> Priority first</label>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="copyTxt">Copy plain text</button>
            <button id="copyCsv" class="secondary">Copy CSV</button>
            <button id="copyHtml" class="secondary">Copy publisher-safe HTML</button>
          </div>
          <div class="muted" style="margin-top:10px">Preview of copied output…</div>
          <textarea id="preview" spellcheck="false"></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- helpers
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const delay = ms => new Promise(r => setTimeout(r, ms));

    const BLOB_KEY = 'watchlist-accounts';
    // Treat server value as "uninitialized" if updatedAt is null/undefined
    async function loadBlobRaw(){
      try{
        const r=await fetch('/api/watchlist-accounts');
        if(!r.ok) return null;
        const ct=r.headers.get('content-type')||'';
        if(!ct.includes('application/json')) return null;
        return await r.json(); // {enabled:[], updatedAt:...}
      }catch{return null}
    }
    async function loadBlob(){
      const obj = await loadBlobRaw();
      if(!obj) return null;
      if (obj.updatedAt == null) return null; // ignore empty bootstrap
      return Array.isArray(obj.enabled) ? obj.enabled : null;
    }
    async function saveBlob(enabled){
      try{
        await fetch('/api/watchlist-accounts',{
          method:'POST',headers:{'content-type':'application/json'},
          body:JSON.stringify({enabled})
        });
      }catch{}
    }
    function loadLocal(){
      try{ const x=localStorage.getItem(BLOB_KEY); return x!==null?JSON.parse(x):null }catch{return null}
    }
    function saveLocal(enabled){ try{ localStorage.setItem(BLOB_KEY,JSON.stringify(enabled)) }catch{} }

    function profileUrl(handle, did){
      if (did && /^did:plc:/.test(did)) return `https://bsky.app/profile/${did}`;
      if (handle) return `https://bsky.app/profile/${handle.replace(/^@/,'')}`;
      return '';
    }

    // reporters.csv
    async function fetchReporters(){
      const res = await fetch('/reporters.csv?_=' + Date.now());
      const txt = await res.text();
      const lines = txt.trim().split(/\r?\n/).filter(Boolean);
      return lines.map(line=>{
        const [h,p] = line.split(',').map(s=>s.trim());
        const handle = h.startsWith('@')?h:'@'+h;
        const priority = (p||'').toLowerCase()==='true';
        return {handle, priority};
      });
    }

    async function buildAccountsUI(){
      const reporters = await fetchReporters();
      const box = $('#accountsBox');
      box.innerHTML = '';

      const server = await loadBlob();       // null if none OR uninitialized
      const local  = loadLocal();            // null if never saved locally
      const defaultAll = reporters.map(r=>r.handle);

      // precedence: server (if not null) -> local (if not null) -> ALL
      const enabled = (server!==null) ? server : (local!==null ? local : defaultAll);

      // build
      reporters.forEach((r,i)=>{
        const id='acc_'+i;
        const checked = enabled.includes(r.handle);
        const el = document.createElement('label');
        el.className='chip';
        el.innerHTML = `<input type="checkbox" id="${id}" data-handle="${r.handle}" ${checked?'checked':''}/>
                        <span>${r.handle}</span>${r.priority?'<span class="pill">priority</span>':''}`;
        box.appendChild(el);
      });

      box.addEventListener('change', ()=>{
        const list = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        saveLocal(list); saveBlob(list);
      });

      // If we used ALL as default (first ever), persist that now so future loads keep it:
      if (server===null && local===null) {
        const list = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        saveLocal(list); saveBlob(list);
      }

      return reporters;
    }

    // UI helpers
    function updateSelectedCounts(){ $('#selCount').textContent = $$('#results input[type="checkbox"]:checked').length; }

    function utm(url){
      try{
        const u = new URL(url);
        if(!u.searchParams.has('utm_source')) u.searchParams.set('utm_source','hoopshype');
        return u.toString();
      }catch{return url}
    }

    function linkifyText(s) {
      const urlRe = /https?:\/\/[^\s<>()'"]+/g;
      return (s||'').replace(/\n/g,'<br>').replace(urlRe, m => `<a href="${m}" target="_blank" rel="noopener">${m}</a>`);
    }

    function collectLinksFromHTML(html){
      const links = [];
      if (!html) return links;
      const div = document.createElement('div'); div.innerHTML = html;
      div.querySelectorAll('a[href]').forEach(a => links.push(a.href));
      // Also any <source src> inside <video>
      div.querySelectorAll('source[src],video[src]').forEach(el=>links.push(el.getAttribute('src')));
      return Array.from(new Set(links));
    }
    function collectLinksFromText(text){
      const urlRe = /https?:\/\/[^\s<>()'"]+/g;
      return (text.match(urlRe) || []);
    }
    function extractAllLinks(it){
      const arr = [];
      arr.push(...collectLinksFromHTML(it.html||''));
      arr.push(...collectLinksFromText(it.text||''));
      if (it.mediaUrl) arr.push(it.mediaUrl);
      if (it.url) arr.push(it.url);
      return Array.from(new Set(arr));
    }
    function pickVideo(links){
      return links.find(u => /(youtube\.com|youtu\.be|vimeo\.com|\.mp4($|\?)|\.webm($|\?)|\.mov($|\?))/i.test(u)) || '';
    }

    function renderItems(items){
      const container = $('#results');
      container.innerHTML='';
      const frag = document.createDocumentFragment();

      items.forEach((it,i)=>{
        const links = extractAllLinks(it);
        const vUrl = pickVideo(links);
        const blueskyUrl = utm(it.url || '');

        const author = it.authorDisplay || it.authorHandle || '';
        const profile = profileUrl(it.authorHandle, it.authorDid);
        const authorHTML = profile ? `<a href="${profile}" target="_blank" rel="noopener">${author}</a>` : author;

        const bodyHTML = it.html
          ? it.html
          : linkifyText(it.text || '');

        const extraLinks = links.filter(u => u !== it.url);
        const extraLinksHtml = extraLinks.length
            ? `<div class="links">Links: ${extraLinks.map(u=>`<a href="${u}" target="_blank" rel="noopener">${u}</a>`).join(' ')}</div>`
            : '';

        const el = document.createElement('div');
        el.className='item';
        el.innerHTML = `
          <label style="display:flex;gap:10px;align-items:start;">
            <input type="checkbox" data-idx="${i}" />
            <div style="flex:1">
              <div class="meta">
                <span>${authorHTML}</span>
                ${it.authorHandle?`<span class="muted">${it.authorHandle}</span>`:''}
                ${it.tsLocal?`<span class="muted">${it.tsLocal}</span>`:''}
                ${typeof it.likeCount==='number'?`<span class="muted">❤ ${it.likeCount}</span>`:''}
                ${typeof it.repostCount==='number'?`<span class="muted">↻ ${it.repostCount}</span>`:''}
              </div>
              <div>${bodyHTML}</div>
              ${vUrl ? `<div class="muted" style="margin-top:6px;"><a href="${vUrl}" target="_blank" rel="noopener">Open video</a></div>` : ''}
              ${extraLinksHtml}
              ${blueskyUrl?`<div class="muted" style="margin-top:6px"><a href="${blueskyUrl}" target="_blank" rel="noopener">Open on Bluesky</a></div>`:''}
            </div>
          </label>
        `;
        frag.appendChild(el);
      });

      container.appendChild(frag);
      container.addEventListener('change',(e)=>{ if(e.target.matches('input[type="checkbox"]')) updateSelectedCounts(); }, {once:true});
      updateSelectedCounts();
    }

    function collectSelected(items){
      const idx = new Set($$('#results input[type="checkbox"]:checked').map(i=>+i.dataset.idx));
      return items.filter((_,i)=>idx.has(i));
    }

    function oneLineText(s){
      return (s||'').replace(/\s*\n+\s*/g,' ').replace(/\s\s+/g,' ').trim();
    }
    function copyPlain(selected){
      const lines = selected.map(s=>{
        const author = s.authorDisplay || s.authorHandle || '';
        const text = oneLineText(s.text || (s.html||'').replace(/<[^>]+>/g,' '));
        const link = utm(s.url || '');
        return `${author}: ${text} ${link}`.trim();
      });
      const out = lines.join('\n');
      navigator.clipboard.writeText(out);
      $('#preview').value = out;
    }
    function toCSV(rows){
      const esc=v=>`"${String(v??'').replace(/"/g,'""')}"`;
      const head=['authorDisplay','authorHandle','tsLocal','likeCount','repostCount','url','text'];
      const lines=[head.map(esc).join(',')];
      rows.forEach(r=>lines.push([r.authorDisplay,r.authorHandle,r.tsLocal,r.likeCount,r.repostCount,utm(r.url||''),oneLineText(r.text||'')].map(esc).join(',')));
      return lines.join('\n');
    }
    function copyCSV(selected){
      const out=toCSV(selected); navigator.clipboard.writeText(out); $('#preview').value=out;
    }
    function copyHTML(selected){
      const html = selected.map(s=>{
        const line1 = `<strong>${s.authorDisplay || s.authorHandle || ''}</strong> <span style="color:#667">${s.tsLocal || ''}</span>`;
        const text = (s.text || '').replace(/\n/g,'<br>');
        const link = s.url ? ` <a href="${utm(s.url)}" target="_blank" rel="noopener">${utm(s.url)}</a>` : '';
        return `<p>${line1}<br>${text}${link}</p>`;
      }).join('\n');
      navigator.clipboard.writeText(html); $('#preview').value=html;
    }

    // strict repost filter
    function isRepostItem(it){
      if (it.isRepost === true) return true;
      const ht = (it.html || '').replace(/<[^>]+>/g,' ').trim();
      const tx = (it.text || '').trim();
      if (/^\[?repost\b/i.test(ht) || /^\[?repost\b/i.test(tx)) return true;
      return false;
    }

    async function fetchStreamChunk(params){
      const qs = new URLSearchParams(params);
      const r = await fetch('/api/stream?'+qs.toString());
      const ct = r.headers.get('content-type')||'';
      if(!r.ok || !ct.includes('application/json')){
        throw new Error(`Stream error (${r.status})`);
      }
      return r.json();
    }

    async function runBatchedStream(allAuthors, opts){
      const { q, hours, minReposts, minLikes, includeReplies, includeQuotes, excludeReposts, limit, sort, nocache, priorityFirst } = opts;

      const CHUNK = 20;
      const chunks=[]; for(let i=0;i<allAuthors.length;i+=CHUNK) chunks.push(allAuthors.slice(i,i+CHUNK));

      // generous over-fetch to avoid starving after filters
      const perChunkLimit = Math.max(60, Math.ceil((limit*4)/chunks.length));

      const reqs = chunks.map(chunk => fetchStreamChunk({
        q: q || '',
        hours: hours || 6,
        minReposts: minReposts || 0,
        minLikes: minLikes || 0,
        includeReplies: includeReplies ? 1 : 0,
        includeQuotes: includeQuotes ? 1 : 0,
        authors: chunk.join(','),
        limit: perChunkLimit,
        sort: sort || 'desc',
        nocache: nocache ? 1 : 0,
        priorityFirst: priorityFirst ? 1 : 0
      }));

      const res = await Promise.all(reqs);
      const all = res.flatMap(x => Array.isArray(x.items)?x.items:[]);

      // filter FIRST
      let filtered = all.slice();
      if (excludeReposts) filtered = filtered.filter(it => !isRepostItem(it));

      // dedupe
      const seen = new Set(); const out=[];
      for(const it of filtered){
        const key = it.url || `${it.ts}|${it.authorHandle}|${it.text?.slice(0,60)}`;
        if(!seen.has(key)){ seen.add(key); out.push(it); }
      }

      // sort
      const s = sort || 'desc';
      if (s==='likes') out.sort((a,b)=>(b.likeCount||0)-(a.likeCount||0));
      else if (s==='reposts') out.sort((a,b)=>(b.repostCount||0)-(a.repostCount||0));
      else if (s==='asc') out.sort((a,b)=> new Date(a.ts||a.tsLocal||0)-new Date(b.ts||b.tsLocal||0));
      else out.sort((a,b)=> new Date(b.ts||b.tsLocal||0)-new Date(a.ts||a.tsLocal||0));

      return out.slice(0, limit || 60);
    }

    let currentItems = [];

    async function runSearch(reporters){
      $('#err').textContent=''; $('#spin').classList.add('on');
      try{
        const q=$('#q').value.trim();
        const hours=+$('#hours').value||6;
        const minReposts=+$('#minReposts').value||0;
        const minLikes=+$('#minLikes').value||0;
        const limit=+$('#limit').value||60;
        const sort=$('#sort').value;
        const includeReplies=$('#incReplies').checked;
        const includeQuotes=$('#incQuotes').checked;
        const excludeReposts=$('#excReposts').checked;
        const nocache=$('#nocache').checked;
        const priorityFirst=$('#priorityFirst').checked;

        const authors = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        if(authors.length===0){ renderItems([]); currentItems=[]; return; }

        const items = await runBatchedStream(authors,{q,hours,minReposts,minLikes,includeReplies,includeQuotes,excludeReposts,limit,sort,nocache,priorityFirst});
        currentItems = items; renderItems(items);
      }catch(e){ $('#err').textContent=e.message||'Error'; renderItems([]); currentItems=[]; }
      finally{ $('#spin').classList.remove('on'); }
    }

    async function init(){
      const reporters = await buildAccountsUI();

      $('#allBtn').addEventListener('click',()=>{
        $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=true);
        const list=$$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
        saveLocal(list); saveBlob(list);
      });
      $('#noneBtn').addEventListener('click',()=>{
        $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=false);
        saveLocal([]); saveBlob([]);
      });

      $('#searchBtn').addEventListener('click',()=>runSearch(reporters));
      $('#copyTxt').addEventListener('click',()=>copyPlain(collectSelected(currentItems)));
      $('#copyCsv').addEventListener('click',()=>copyCSV(collectSelected(currentItems)));
      $('#copyHtml').addEventListener('click',()=>copyHTML(collectSelected(currentItems)));

      // Auto-run the very first time (and after this fix, also when the blob is uninitialized)
      await delay(30);
      await runSearch(reporters);
    }

    init();
  </script>
</body>
</html>

