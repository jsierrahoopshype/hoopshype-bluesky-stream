<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bluesky Watchlist</title>
<style>
  :root{
    --bg:#fff; --text:#111; --muted:#5a6573;
    --panel:#fff; --border:#d9e0ea; --accent:#0b77ff; --chip:#f4f7fb;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  h1{font-weight:700;font-size:20px;margin:0 0 12px}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .row > *{min-height:36px}
  input[type="number"],input[type="text"],select{background:#fff;border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:8px}
  input[type="checkbox"]{transform:translateY(1px)}
  button{background:var(--accent);color:#fff;border:0;border-radius:8px;padding:9px 14px;font-weight:700;cursor:pointer}
  button.secondary{background:#eef3fb;color:#0b2b60;border:1px solid var(--border)}
  .chips{max-height:220px;overflow:auto;border:1px solid var(--border);border-radius:12px;padding:10px;margin-top:8px;background:#fff}
  .chip{display:inline-flex;align-items:center;gap:8px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:999px;padding:6px 10px;margin:6px 6px 0 0;white-space:nowrap}
  .muted{color:var(--muted)}
  .results{display:flex;flex-direction:column;gap:12px;margin-top:10px}
  .item{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff}
  .item .meta{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;gap:8px;flex-wrap:wrap}
  .links{margin-top:6px;font-size:12px;color:var(--muted)}
  .links a{margin-right:8px}
  .right-sticky{position:sticky;top:12px;height:calc(100dvh - 48px)}
  .right-sticky .card{height:100%;display:flex;flex-direction:column}
  .right-sticky .card textarea{flex:1;min-height:200px;background:#fff;border:1px solid var(--border);border-radius:12px;color:var(--text);padding:10px;resize:vertical}
  .pill{display:inline-flex;background:#eef3fb;border:1px solid var(--border);border-radius:999px;padding:4px 8px;font-size:12px;margin-right:6px}
  .spinner{display:none}
  .spinner.on{display:inline-block;inline-size:14px;block-size:14px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .8s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .error{color:#c21d12;font-weight:600}
  a{color:#0b58d1;text-decoration:none}
  a:hover{text-decoration:underline}
</style>
</head>
<body>
<div class="wrap">
  <h1>Bluesky Watchlist</h1>
  <div class="grid">
    <div class="card">
      <div class="row">
        <input id="q" type="text" placeholder="(optional filter in post text)" style="flex:1 1 320px">
        <label>Lookback (h) <input id="hours" type="number" min="1" value="24" style="width:76px"></label>
        <label>Min reposts <input id="minReposts" type="number" min="0" value="0" style="width:70px"></label>
        <label>Min likes <input id="minLikes" type="number" min="0" value="0" style="width:70px"></label>
        <label>Limit <input id="limit" type="number" min="1" value="150" style="width:70px"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <select id="sort">
          <option value="desc">Recent (desc)</option>
          <option value="asc">Oldest (asc)</option>
          <option value="likes">Most likes</option>
          <option value="reposts">Most reposts</option>
        </select>
        <label><input id="incReplies" type="checkbox"> Include replies</label>
        <label><input id="incQuotes" type="checkbox" checked> Include quotes</label>
        <label><input id="excReposts" type="checkbox" checked> Exclude reposts</label>
        <label><input id="nocache" type="checkbox" checked> nocache</label>
        <button id="searchBtn">Search <span id="spin" class="spinner"></span></button>
        <button id="allBtn" class="secondary">All</button>
        <button id="noneBtn" class="secondary">None</button>
        <span id="err" class="error" role="alert"></span>
      </div>

      <div class="muted" style="margin-top:10px">Accounts (from <code>reporters.csv</code>)</div>
      <div id="accountsBox" class="chips"></div>

      <div id="results" class="results"></div>
    </div>

    <div class="right-sticky">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="muted">Selected <span id="selCount">0</span></div>
          <label class="muted"><input id="priorityFirst" type="checkbox" checked> Priority first</label>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="copyTxt">Copy plain text</button>
          <button id="copyCsv" class="secondary">Copy CSV</button>
          <button id="copyHtml" class="secondary">Copy publisher-safe HTML</button>
        </div>
        <div class="muted" style="margin-top:10px">Preview of copied output…</div>
        <textarea id="preview" spellcheck="false"></textarea>
      </div>
    </div>
  </div>
</div>

<script>
/* ============ small utils ============ */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const delay = ms => new Promise(r => setTimeout(r, ms));
const URL_RE = /https?:\/\/[^\s<>()'"]+/g;
const utm = url => {
  try{ const u=new URL(url); if(!u.searchParams.has('utm_source')) u.searchParams.set('utm_source','hoopshype'); return u.toString(); }
  catch{ return url }
};
const decode = s => { const t=document.createElement('textarea'); t.innerHTML=s||''; return t.value; };
const stripTags = h => (h||'').replace(/<[^>]+>/g,'');
const oneline = s => (s||'').replace(/\s*\n+\s*/g,' ').replace(/\s\s+/g,' ').trim();
const linkify = s => (s||'').replace(/\n/g,'<br>').replace(URL_RE, m=>`<a target="_blank" rel="noopener" href="${m}">${m}</a>`);
const prof = (handle,did)=> did && /^did:plc:/.test(did) ? `https://bsky.app/profile/${did}` : (handle?`https://bsky.app/profile/${handle.replace(/^@/,'')}`:'');

/* ============ robust CSV parsing ============ */
function parseCSV(text){
  // Basic RFC4180-ish parser (no deps)
  const rows=[]; let i=0, cur=[], cell='', inQ=false;
  while(i<=text.length){
    const c=text[i]||'\n';
    if(inQ){
      if(c==='"' && text[i+1]==='"'){ cell+='"'; i+=2; continue; }
      if(c==='"'){ inQ=false; i++; continue; }
      cell+=c; i++; continue;
    }else{
      if(c==='"' ){ inQ=true; i++; continue; }
      if(c===',' ){ cur.push(cell); cell=''; i++; continue; }
      if(c==='\n' || i===text.length){ cur.push(cell); rows.push(cur); cur=[]; cell=''; i++; continue; }
      cell+=c; i++; continue;
    }
  }
  return rows.filter(r=>r.length && r.some(x=>x.trim()!==''));
}
function extractHandlesFromRows(rows){
  if(!rows.length) return [];
  // If first row contains 'handle' header, use that column; else try first col that looks like a handle
  const header = rows[0].map(h=>h.trim().toLowerCase());
  let body = rows;
  let idx = header.findIndex(h=>h==='handle' || h==='author' || h==='username');
  if(idx>=0){ body = rows.slice(1); }
  else{ idx = 0; } // fallback: first column

  const looksHandle = v => /^@?[\w.-]+(?:\.[\w.-]+)*$/.test(v) || /bsky\.social/.test(v);
  // If chosen column isn't handle-like, find one that is
  if(body.length && !looksHandle((body[0][idx]||'').trim())){
    const col = body[0].findIndex(v=>looksHandle((v||'').trim()));
    if(col>=0) idx=col;
  }
  const toHandle = v=>{
    let s=(v||'').trim();
    // take only the handle-ish token if a cell had multiple fields like '@foo | Name'
    const m = s.match(/@[\w\.-]+(?:\.[\w\.-]+)*/);
    if(m) s=m[0];
    if(!s.startsWith('@')) s='@'+s;
    return s;
  };
  return body.map(r=>toHandle(r[idx])).filter(h=>looksHandle(h.replace(/^@/,'')));
}

/* ============ reporters.csv ============ */
async function fetchReporters(){
  const res = await fetch('/reporters.csv?_='+Date.now());
  const txt = await res.text();
  const rows = parseCSV(txt);
  const handles = extractHandlesFromRows(rows);
  // mark 'priority' if there's a priority column
  const header = rows[0]?.map(h=>h.trim().toLowerCase())||[];
  const prIdx = header.findIndex(h=>h==='priority');
  const map = new Map();
  if(prIdx>=0){
    rows.slice(1).forEach(r=>{
      const h = (r[header.findIndex(h=>h==='handle')||0]||'').trim();
      if(!h) return;
      const handle = h.startsWith('@')?h:'@'+h;
      const priority = String(r[prIdx]||'').trim().toLowerCase()==='true';
      map.set(handle, priority);
    });
  }
  return handles.map(h=>({handle:h, priority: map.get(h)===true}));
}

/* ============ blob/local persistence ============ */
const BLOB_KEY='watchlist-accounts';
async function loadBlobRaw(){
  try{ const r=await fetch('/api/watchlist-accounts'); if(!r.ok) return null;
       const ct=r.headers.get('content-type')||''; if(!ct.includes('application/json')) return null;
       return await r.json();
  }catch{return null}
}
async function saveBlob(enabled){ try{ await fetch('/api/watchlist-accounts',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({enabled})}); }catch{} }
function loadLocal(){ try{ return JSON.parse(localStorage.getItem(BLOB_KEY)||'null') }catch{return null} }
function saveLocal(enabled){ try{ localStorage.setItem(BLOB_KEY,JSON.stringify(enabled)) }catch{} }

/* ============ UI building ============ */
async function buildAccountsUI(){
  const reporters = await fetchReporters();
  const box = $('#accountsBox'); box.innerHTML='';

  const server=await loadBlobRaw();
  const serverEnabled = server && Array.isArray(server.enabled) ? server.enabled : null;
  const localEnabled = loadLocal();
  const fallToAll = arr => (!arr || (Array.isArray(arr) && arr.length===0));
  const allHandles = reporters.map(r=>r.handle);
  const enabled = fallToAll(serverEnabled) && fallToAll(localEnabled) ? allHandles :
                  !fallToAll(serverEnabled) ? serverEnabled : localEnabled;

  reporters.forEach((r,i)=>{
    const id='acc_'+i;
    const checked = enabled.includes(r.handle);
    const el=document.createElement('label');
    el.className='chip';
    el.innerHTML=`
      <input type="checkbox" id="${id}" data-handle="${r.handle}" ${checked?'checked':''}/>
      <a href="${prof(r.handle)}" target="_blank" rel="noopener">${r.handle}</a>
      ${r.priority?'<span class="pill">priority</span>':''}`;
    box.appendChild(el);
  });

  box.addEventListener('change', ()=>{
    const list=$$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
    saveLocal(list); saveBlob(list);
  });

  if (fallToAll(serverEnabled) && fallToAll(localEnabled)) { // first time or empty => save ALL
    saveLocal(allHandles); saveBlob(allHandles);
  }
  return reporters;
}

/* ============ rendering ============ */
function extractLinksFromHtml(html){
  const out=[]; if(!html) return out;
  const d=document.createElement('div'); d.innerHTML=html;
  d.querySelectorAll('a[href]').forEach(a=>out.push(a.href));
  d.querySelectorAll('img[src]').forEach(i=>out.push(i.getAttribute('src')));
  return Array.from(new Set(out));
}
function extractLinksFromText(text){ return Array.from(new Set((text||'').match(URL_RE)||[])); }

function render(items){
  const c=$('#results'); c.innerHTML='';
  const frag=document.createDocumentFragment();

  items.forEach((it,i)=>{
    const author = it.authorDisplay || it.authorHandle || '';
    const profile = prof(it.authorHandle, it.authorDid);
    const authorHTML = profile ? `<a href="${profile}" target="_blank" rel="noopener">${author}</a>` : author;
    const bodyHTML = it.html ? it.html : linkify(it.text||'');
    const moreLinks = Array.from(new Set([
      ...extractLinksFromHtml(it.html||''),
      ...extractLinksFromText(it.text||'')
    ]));
    const blueskyUrl = utm(it.url||'');

    const el=document.createElement('div');
    el.className='item';
    el.innerHTML=`
      <label style="display:flex;gap:10px;align-items:start;">
        <input type="checkbox" data-idx="${i}"/>
        <div style="flex:1">
          <div class="meta">
            <span>${authorHTML}</span>
            ${it.authorHandle?`<span class="muted">${it.authorHandle}</span>`:''}
            ${it.tsLocal?`<span class="muted">${it.tsLocal}</span>`:''}
            ${typeof it.likeCount==='number'?`<span class="muted">❤ ${it.likeCount}</span>`:''}
            ${typeof it.repostCount==='number'?`<span class="muted">↻ ${it.repostCount}</span>`:''}
          </div>
          <div>${bodyHTML}</div>
          ${moreLinks.length?`<div class="links">Links: ${moreLinks.map(u=>`<a href="${u}" target="_blank" rel="noopener">${u}</a>`).join(' ')}</div>`:''}
          ${blueskyUrl?`<div class="muted" style="margin-top:6px"><a href="${blueskyUrl}" target="_blank" rel="noopener">Open on Bluesky</a></div>`:''}
        </div>
      </label>`;
    frag.appendChild(el);
  });

  c.appendChild(frag);
  c.addEventListener('change',e=>{ if(e.target.matches('input[type="checkbox"]')) updateSel(); }, {once:true});
  updateSel();
}
function updateSel(){ $('#selCount').textContent = $$('#results input[type="checkbox"]:checked').length; }
function selected(items){
  const idx=new Set($$('#results input[type="checkbox"]:checked').map(i=>+i.dataset.idx));
  return items.filter((_,i)=>idx.has(i));
}

/* ============ copy formats ============ */
function copyPlain(items){
  const lines = items.map(it=>{
    const author = it.authorDisplay || it.authorHandle || '';
    const text = oneline(decode(it.text || stripTags(it.html) || ''));
    const link = utm(it.url||'');
    return `${author}: ${text}\n\n${link}`.trim();
  });
  const out = lines.join('\n\n');
  navigator.clipboard.writeText(out);
  $('#preview').value=out;
}
function toCSV(rows){
  const esc=v=>`"${String(v??'').replace(/"/g,'""')}"`;
  const head=['authorDisplay','authorHandle','tsLocal','likeCount','repostCount','url','text'];
  const lines=[head.map(esc).join(',')];
  rows.forEach(r=>lines.push([r.authorDisplay,r.authorHandle,r.tsLocal,r.likeCount,r.repostCount,utm(r.url||''),oneline(decode(r.text||stripTags(r.html)||''))].map(esc).join(',')));
  return lines.join('\n');
}
function copyCSV(items){ const out=toCSV(items); navigator.clipboard.writeText(out); $('#preview').value=out; }
function copyHTML(items){
  const html = items.map(s=>{
    const line1 = `<strong>${s.authorDisplay || s.authorHandle || ''}</strong> <span style="color:#667">${s.tsLocal || ''}</span>`;
    const text = (s.html ? s.html : linkify(s.text||''));
    const link = s.url ? ` <a href="${utm(s.url)}" target="_blank" rel="noopener">${utm(s.url)}</a>` : '';
    return `<p>${line1}<br>${text}${link}</p>`;
  }).join('\n');
  navigator.clipboard.writeText(html); $('#preview').value=html;
}

/* ============ fetching ============ */
function isRepost(it){
  if (it.isRepost === true) return true;
  const ht=(it.html||'').replace(/<[^>]+>/g,' ').trim();
  const tx=(it.text||'').trim();
  if (/^\[?repost\b/i.test(ht) || /^\[?repost\b/i.test(tx)) return true;
  return false;
}
async function fetchJSON(url){
  const r=await fetch(url);
  const ct=r.headers.get('content-type')||'';
  if(!ct.includes('application/json')){
    const text=await r.text();
    throw new Error(`Request failed (${r.status}). Expected JSON, got: ${text.slice(0,120)}…`);
  }
  if(!r.ok) throw new Error(`Request failed (${r.status})`);
  return r.json();
}
async function chunkFetch(params){
  const qs = new URLSearchParams(params);
  return fetchJSON('/api/stream?'+qs.toString());
}
function sortItems(arr, sort){
  const s=sort||'desc';
  if(s==='likes') arr.sort((a,b)=>(b.likeCount||0)-(a.likeCount||0));
  else if(s==='reposts') arr.sort((a,b)=>(b.repostCount||0)-(a.repostCount||0));
  else if(s==='asc') arr.sort((a,b)=> new Date(a.ts||a.tsLocal||0)-new Date(b.ts||b.tsLocal||0));
  else arr.sort((a,b)=> new Date(b.ts||b.tsLocal||0)-new Date(a.ts||a.tsLocal||0));
}
async function mainBatch(authors,opt){
  const CH=12, chunks=[]; for(let i=0;i<authors.length;i+=CH) chunks.push(authors.slice(i,i+CH));
  const perChunkLimit = Math.max(120, Math.ceil((opt.limit*6)/chunks.length));
  const reqs = chunks.map(list=> chunkFetch({
    q:opt.q||'', hours:opt.hours||24, minReposts:opt.minReposts||0, minLikes:opt.minLikes||0,
    includeReplies:opt.includeReplies?1:0, includeQuotes:opt.includeQuotes?1:0,
    authors:list.join(','), limit:perChunkLimit, sort:opt.sort||'desc', nocache:opt.nocache?1:0
  }));
  const res = await Promise.all(reqs);
  let all = res.flatMap(x=>Array.isArray(x.items)?x.items:[]);
  if (opt.excludeReposts) all = all.filter(it=>!isRepost(it));
  const seen=new Set, out=[];
  for(const it of all){
    const k = it.url || `${it.ts}|${it.authorHandle}|${(it.text||'').slice(0,80)}`;
    if(!seen.has(k)){ seen.add(k); out.push(it); }
  }
  sortItems(out,opt.sort);
  return out.slice(0,opt.limit||150);
}
async function gapFill(authors, got, opt){
  const have=new Set(got.map(i=>i.authorHandle).filter(Boolean));
  const missing = authors.filter(h=>!have.has(h));
  if(!missing.length) return [];
  const hours2=Math.max(+opt.hours||24, 48);
  const perAuthor=Math.max(80, Math.ceil((opt.limit||150)/3));
  const reqs = missing.map(h=> chunkFetch({
    q:opt.q||'', hours:hours2, minReposts:opt.minReposts||0, minLikes:opt.minLikes||0,
    includeReplies:opt.includeReplies?1:0, includeQuotes:opt.includeQuotes?1:0,
    authors:h, limit:perAuthor, sort:opt.sort||'desc', nocache:opt.nocache?1:0
  }).catch(()=>({items:[]})));
  const res = await Promise.all(reqs);
  let more = res.flatMap(x=>Array.isArray(x.items)?x.items:[]);
  if(opt.excludeReposts) more = more.filter(it=>!isRepost(it));
  return more;
}

let CURRENT=[];
async function run(){
  $('#err').textContent=''; $('#spin').classList.add('on');
  try{
    const authors = $$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
    if(!authors.length){ render([]); CURRENT=[]; return; }
    const opt = {
      q:$('#q').value.trim(), hours:+$('#hours').value||24,
      minReposts:+$('#minReposts').value||0, minLikes:+$('#minLikes').value||0,
      includeReplies:$('#incReplies').checked, includeQuotes:$('#incQuotes').checked,
      excludeReposts:$('#excReposts').checked, limit:+$('#limit').value||150,
      sort:$('#sort').value, nocache:$('#nocache').checked
    };
    const primary = await mainBatch(authors,opt);
    const extra    = await gapFill(authors, primary, opt);
    const all=[...primary,...extra];
    const seen=new Set, out=[];
    for(const it of all){
      const k = it.url || `${it.ts}|${it.authorHandle}|${(it.text||'').slice(0,80)}`;
      if(!seen.has(k)){ seen.add(k); out.push(it); }
    }
    sortItems(out,opt.sort);
    CURRENT = out.slice(0,opt.limit||150);
    render(CURRENT);
  }catch(e){ $('#err').textContent=e.message||'Error'; render([]); CURRENT=[]; }
  finally{ $('#spin').classList.remove('on'); }
}

/* ============ init ============ */
async function init(){
  await buildAccountsUI();

  $('#allBtn').addEventListener('click',()=>{
    $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=true);
    const list=$$('#accountsBox input[type="checkbox"]:checked').map(i=>i.dataset.handle);
    saveLocal(list); saveBlob(list);
  });
  $('#noneBtn').addEventListener('click',()=>{
    $$('#accountsBox input[type="checkbox"]').forEach(i=>i.checked=false);
    saveLocal([]); saveBlob([]);
  });

  $('#searchBtn').addEventListener('click',run);
  $('#copyTxt').addEventListener('click',()=>copyPlain(selected(CURRENT)));
  $('#copyCsv').addEventListener('click',()=>copyCSV(selected(CURRENT)));
  $('#copyHtml').addEventListener('click',()=>copyHTML(selected(CURRENT)));

  // Auto-run on first load (ALL reporters are auto-enabled when blob/local is empty)
  await delay(40);
  run();
}
init();
</script>
</body>
</html>
